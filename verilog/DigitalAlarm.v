/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module ClockDev (
  input EN,
  input CLR,
  input CLK,
  output [5:0] SEC,
  output [5:0] MIN,
  output [4:0] HOUR
);
  wire s0;
  wire s1;
  // SECONDS
  DIG_CounterPreset #(
    .Bits(6),
    .maxValue(60)
  )
  DIG_CounterPreset_i0 (
    .en( EN ),
    .C( CLK ),
    .dir( 1'b0 ),
    .in( 6'b0 ),
    .ld( 1'b0 ),
    .clr( CLR ),
    .out( SEC ),
    .ovf( s0 )
  );
  // MINUTES
  DIG_CounterPreset #(
    .Bits(6),
    .maxValue(60)
  )
  DIG_CounterPreset_i1 (
    .en( s0 ),
    .C( CLK ),
    .dir( 1'b0 ),
    .in( 6'b0 ),
    .ld( 1'b0 ),
    .clr( CLR ),
    .out( MIN ),
    .ovf( s1 )
  );
  // HOURS
  DIG_CounterPreset #(
    .Bits(5),
    .maxValue(24)
  )
  DIG_CounterPreset_i2 (
    .en( s1 ),
    .C( CLK ),
    .dir( 1'b0 ),
    .in( 5'b0 ),
    .ld( 1'b0 ),
    .clr( CLR ),
    .out( HOUR )
  );
endmodule
module LUT_DECODER (
    input \0 ,
    input \1 ,
    input \2 ,
    input \3 ,
    output reg  [6:0]  out
);
    reg [6:0] my_lut [0:15];
    wire [3:0] temp;
    assign temp = {\3 , \2 , \1 , \0 };

    always @ (*) begin
       out = my_lut[temp];
    end

    initial begin
        my_lut[0] = 7'h7e;
        my_lut[1] = 7'h30;
        my_lut[2] = 7'h6d;
        my_lut[3] = 7'h79;
        my_lut[4] = 7'h33;
        my_lut[5] = 7'h5b;
        my_lut[6] = 7'h5f;
        my_lut[7] = 7'h70;
        my_lut[8] = 7'h7f;
        my_lut[9] = 7'h7b;
        my_lut[10] = 7'h77;
        my_lut[11] = 7'h1f;
        my_lut[12] = 7'h4e;
        my_lut[13] = 7'h3d;
        my_lut[14] = 7'h4f;
        my_lut[15] = 7'h47;
    end
endmodule


module SevenSegmentDecoder (
  input IN_0,
  input IN_1,
  input IN_2,
  input IN_3,
  output A,
  output B,
  output C,
  output D,
  output E,
  output F,
  output G
);
  wire [6:0] s0;
  // DECODER
  LUT_DECODER LUT_DECODER_i0 (
    .\0 ( IN_0 ),
    .\1 ( IN_1 ),
    .\2 ( IN_2 ),
    .\3 ( IN_3 ),
    .out( s0 )
  );
  assign A = s0[6];
  assign B = s0[5];
  assign C = s0[4];
  assign D = s0[3];
  assign E = s0[2];
  assign F = s0[1];
  assign G = s0[0];
endmodule

module \2DisplayDriver  (
  input [5:0] DATA_IN,
  output [6:0] SEG_1,
  output [6:0] SEG_2
);
  wire s0;
  wire s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire s19;
  assign s0 = DATA_IN[0];
  assign s1 = DATA_IN[1];
  assign s2 = DATA_IN[2];
  assign s3 = DATA_IN[3];
  assign s11 = DATA_IN[4];
  assign s12 = DATA_IN[5];
  SevenSegmentDecoder SevenSegmentDecoder_i0 (
    .IN_0( s0 ),
    .IN_1( s1 ),
    .IN_2( s2 ),
    .IN_3( s3 ),
    .A( s4 ),
    .B( s5 ),
    .C( s6 ),
    .D( s7 ),
    .E( s8 ),
    .F( s9 ),
    .G( s10 )
  );
  SevenSegmentDecoder SevenSegmentDecoder_i1 (
    .IN_0( s11 ),
    .IN_1( s12 ),
    .IN_2( 1'b0 ),
    .IN_3( 1'b0 ),
    .A( s13 ),
    .B( s14 ),
    .C( s15 ),
    .D( s16 ),
    .E( s17 ),
    .F( s18 ),
    .G( s19 )
  );
  assign SEG_1[0] = s4;
  assign SEG_1[1] = s5;
  assign SEG_1[2] = s6;
  assign SEG_1[3] = s7;
  assign SEG_1[4] = s8;
  assign SEG_1[5] = s9;
  assign SEG_1[6] = s10;
  assign SEG_2[0] = s13;
  assign SEG_2[1] = s14;
  assign SEG_2[2] = s15;
  assign SEG_2[3] = s16;
  assign SEG_2[4] = s17;
  assign SEG_2[5] = s18;
  assign SEG_2[6] = s19;
endmodule

module DigitalAlarm (
  input CLK,
  input INC,
  input SET,
  input CLR,
  output [6:0] SEC_SEG_1,
  output [6:0] SEC_SEG_2,
  output [6:0] MIN_SEG_1,
  output [6:0] MIN_SEG_2,
  output [6:0] HR_SEG_1,
  output [6:0] HR_SEG_2
);
  wire s0;
  wire [5:0] s1;
  wire [5:0] s2;
  wire [4:0] s3;
  wire [5:0] s4;
  assign s0 = ((CLK & ~ SET) | (SET & INC));
  ClockDev ClockDev_i0 (
    .EN( 1'b1 ),
    .CLR( CLR ),
    .CLK( s0 ),
    .SEC( s1 ),
    .MIN( s2 ),
    .HOUR( s3 )
  );
  \2DisplayDriver  \2DisplayDriver_i1 (
    .DATA_IN( s1 ),
    .SEG_1( SEC_SEG_1 ),
    .SEG_2( SEC_SEG_2 )
  );
  \2DisplayDriver  \2DisplayDriver_i2 (
    .DATA_IN( s2 ),
    .SEG_1( MIN_SEG_1 ),
    .SEG_2( MIN_SEG_2 )
  );
  assign s4[4:0] = s3;
  assign s4[5] = 1'b0;
  \2DisplayDriver  \2DisplayDriver_i3 (
    .DATA_IN( s4 ),
    .SEG_1( HR_SEG_1 ),
    .SEG_2( HR_SEG_2 )
  );
endmodule
