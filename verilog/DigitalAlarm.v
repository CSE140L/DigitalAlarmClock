/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */

module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module ClockDev (
  input EN,
  input CLR,
  input CLK,
  output [5:0] SEC,
  output [5:0] MIN,
  output [4:0] HOUR
);
  wire s0;
  wire s1;
  // SECONDS
  DIG_CounterPreset #(
    .Bits(6),
    .maxValue(60)
  )
  DIG_CounterPreset_i0 (
    .en( EN ),
    .C( CLK ),
    .dir( 1'b0 ),
    .in( 6'b0 ),
    .ld( 1'b0 ),
    .clr( CLR ),
    .out( SEC ),
    .ovf( s0 )
  );
  // MINUTES
  DIG_CounterPreset #(
    .Bits(6),
    .maxValue(60)
  )
  DIG_CounterPreset_i1 (
    .en( s0 ),
    .C( CLK ),
    .dir( 1'b0 ),
    .in( 6'b0 ),
    .ld( 1'b0 ),
    .clr( CLR ),
    .out( MIN ),
    .ovf( s1 )
  );
  // HOURS
  DIG_CounterPreset #(
    .Bits(5),
    .maxValue(24)
  )
  DIG_CounterPreset_i2 (
    .en( s1 ),
    .C( CLK ),
    .dir( 1'b0 ),
    .in( 5'b0 ),
    .ld( 1'b0 ),
    .clr( CLR ),
    .out( HOUR )
  );
endmodule
module LUT_DECODER (
    input \0 ,
    input \1 ,
    input \2 ,
    input \3 ,
    output reg  [6:0]  out
);
    reg [6:0] my_lut [0:15];
    wire [3:0] temp;
    assign temp = {\3 , \2 , \1 , \0 };

    always @ (*) begin
       out = my_lut[temp];
    end

    initial begin
        my_lut[0] = 7'h7e;
        my_lut[1] = 7'h30;
        my_lut[2] = 7'h35;
        my_lut[3] = 7'h79;
        my_lut[4] = 7'h33;
        my_lut[5] = 7'h5b;
        my_lut[6] = 7'h5f;
        my_lut[7] = 7'h70;
        my_lut[8] = 7'h7f;
        my_lut[9] = 7'h7b;
        my_lut[10] = 7'h7e;
        my_lut[11] = 7'h30;
        my_lut[12] = 7'h35;
        my_lut[13] = 7'h79;
        my_lut[14] = 7'h33;
        my_lut[15] = 7'h5b;
    end
endmodule


module SevenSegmentDecoder (
  input IN_0,
  input IN_1,
  input IN_2,
  input IN_3,
  output A,
  output B,
  output C,
  output D,
  output E,
  output F,
  output G
);
  wire [6:0] s0;
  // DECODER
  LUT_DECODER LUT_DECODER_i0 (
    .\0 ( IN_0 ),
    .\1 ( IN_1 ),
    .\2 ( IN_2 ),
    .\3 ( IN_3 ),
    .out( s0 )
  );
  assign A = s0[0];
  assign B = s0[1];
  assign C = s0[2];
  assign D = s0[3];
  assign E = s0[4];
  assign F = s0[5];
  assign G = s0[6];
endmodule

module DigitalAlarm (
  input CLK,
  input INC,
  input SET,
  input CLR,
  output [6:0] SEC_SEG_1,
  output [6:0] SEC_SEG_2,
  output [6:0] MIN_SEG_1,
  output [6:0] MIN_SEG_2,
  output [6:0] HR_SEG_1,
  output [6:0] HR_SEG_2
);
  wire s0;
  wire [5:0] s1;
  wire [5:0] s2;
  wire [4:0] s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire s19;
  wire s20;
  wire s21;
  wire s22;
  wire s23;
  wire s24;
  wire s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire s30;
  wire s31;
  wire s32;
  wire s33;
  wire s34;
  wire s35;
  wire s36;
  wire s37;
  wire s38;
  wire s39;
  wire s40;
  wire s41;
  wire s42;
  wire s43;
  wire s44;
  wire s45;
  wire s46;
  wire s47;
  wire s48;
  wire s49;
  wire s50;
  wire s51;
  wire s52;
  wire s53;
  wire s54;
  wire s55;
  wire s56;
  wire s57;
  wire s58;
  wire s59;
  wire s60;
  wire s61;
  wire s62;
  assign s0 = ((CLK & ~ SET) | (SET & INC));
  ClockDev ClockDev_i0 (
    .EN( 1'b1 ),
    .CLR( CLR ),
    .CLK( s0 ),
    .SEC( s1 ),
    .MIN( s2 ),
    .HOUR( s3 )
  );
  assign s4 = s2[0];
  assign s5 = s2[1];
  assign s6 = s2[2];
  assign s7 = s2[3];
  assign s8 = s2[4];
  assign s9 = s2[5];
  assign s24 = s1[0];
  assign s25 = s1[1];
  assign s26 = s1[2];
  assign s27 = s1[3];
  assign s28 = s1[4];
  assign s29 = s1[5];
  assign s44 = s3[0];
  assign s45 = s3[1];
  assign s46 = s3[2];
  assign s47 = s3[3];
  assign s48 = s3[4];
  SevenSegmentDecoder SevenSegmentDecoder_i1 (
    .IN_0( s4 ),
    .IN_1( s5 ),
    .IN_2( s6 ),
    .IN_3( s7 ),
    .A( s10 ),
    .B( s11 ),
    .C( s12 ),
    .D( s13 ),
    .E( s14 ),
    .F( s15 ),
    .G( s16 )
  );
  SevenSegmentDecoder SevenSegmentDecoder_i2 (
    .IN_0( s7 ),
    .IN_1( s8 ),
    .IN_2( s9 ),
    .IN_3( 1'b0 ),
    .A( s17 ),
    .B( s18 ),
    .C( s19 ),
    .D( s20 ),
    .E( s21 ),
    .F( s22 ),
    .G( s23 )
  );
  SevenSegmentDecoder SevenSegmentDecoder_i3 (
    .IN_0( s24 ),
    .IN_1( s25 ),
    .IN_2( s26 ),
    .IN_3( s27 ),
    .A( s30 ),
    .B( s31 ),
    .C( s32 ),
    .D( s33 ),
    .E( s34 ),
    .F( s35 ),
    .G( s36 )
  );
  SevenSegmentDecoder SevenSegmentDecoder_i4 (
    .IN_0( s27 ),
    .IN_1( s28 ),
    .IN_2( s29 ),
    .IN_3( 1'b0 ),
    .A( s37 ),
    .B( s38 ),
    .C( s39 ),
    .D( s40 ),
    .E( s41 ),
    .F( s42 ),
    .G( s43 )
  );
  SevenSegmentDecoder SevenSegmentDecoder_i5 (
    .IN_0( s44 ),
    .IN_1( s45 ),
    .IN_2( s46 ),
    .IN_3( s47 ),
    .A( s49 ),
    .B( s50 ),
    .C( s51 ),
    .D( s52 ),
    .E( s53 ),
    .F( s54 ),
    .G( s55 )
  );
  SevenSegmentDecoder SevenSegmentDecoder_i6 (
    .IN_0( s47 ),
    .IN_1( s48 ),
    .IN_2( 1'b0 ),
    .IN_3( 1'b0 ),
    .A( s56 ),
    .B( s57 ),
    .C( s58 ),
    .D( s59 ),
    .E( s60 ),
    .F( s61 ),
    .G( s62 )
  );
  assign SEC_SEG_1[0] = s30;
  assign SEC_SEG_1[1] = s31;
  assign SEC_SEG_1[2] = s32;
  assign SEC_SEG_1[3] = s33;
  assign SEC_SEG_1[4] = s34;
  assign SEC_SEG_1[5] = s35;
  assign SEC_SEG_1[6] = s36;
  assign SEC_SEG_2[0] = s37;
  assign SEC_SEG_2[1] = s38;
  assign SEC_SEG_2[2] = s39;
  assign SEC_SEG_2[3] = s40;
  assign SEC_SEG_2[4] = s41;
  assign SEC_SEG_2[5] = s42;
  assign SEC_SEG_2[6] = s43;
  assign MIN_SEG_1[0] = s10;
  assign MIN_SEG_1[1] = s11;
  assign MIN_SEG_1[2] = s12;
  assign MIN_SEG_1[3] = s13;
  assign MIN_SEG_1[4] = s14;
  assign MIN_SEG_1[5] = s15;
  assign MIN_SEG_1[6] = s16;
  assign MIN_SEG_2[0] = s17;
  assign MIN_SEG_2[1] = s18;
  assign MIN_SEG_2[2] = s19;
  assign MIN_SEG_2[3] = s20;
  assign MIN_SEG_2[4] = s21;
  assign MIN_SEG_2[5] = s22;
  assign MIN_SEG_2[6] = s23;
  assign HR_SEG_1[0] = s49;
  assign HR_SEG_1[1] = s50;
  assign HR_SEG_1[2] = s51;
  assign HR_SEG_1[3] = s52;
  assign HR_SEG_1[4] = s53;
  assign HR_SEG_1[5] = s54;
  assign HR_SEG_1[6] = s55;
  assign HR_SEG_2[0] = s56;
  assign HR_SEG_2[1] = s57;
  assign HR_SEG_2[2] = s58;
  assign HR_SEG_2[3] = s59;
  assign HR_SEG_2[4] = s60;
  assign HR_SEG_2[5] = s61;
  assign HR_SEG_2[6] = s62;
endmodule
